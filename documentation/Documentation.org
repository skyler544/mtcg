#+TITLE: Project Documentation
:FILE-OPTIONS:
#+STARTUP: fold
#+OPTIONS: toc:nil
#+OPTIONS: num:2
#+OPTIONS: \n:t
#+LATEX_HEADER: \usepackage{helvet}
#+LATEX_HEADER: \renewcommand{\familydefault}{\sfdefault}
#+LATEX_HEADER: \usepackage{nopageno}
#+LATEX_HEADER: \setlength{\parindent}{0pt}
#+LATEX_HEADER: \usepackage[a4paper, margin=2.5cm]{geometry}
:END:

* Design
The application is structured in layers. Each layer has an area of concern for
which it should be responsible, with as little mixing as possible between the
layers. Furthermore, any one layer should only touch the layer immediately
beneath it, and never any deeper than a single layer. The layer hierarchy is as
follows:

+ Controllers
  - Services
    + Models
    + Repositories

** Controllers
Controllers are responsible for receiving Http Requests and creating and sending
Http Responses. The pattern is simple:
1. Get a request object
2. Authenticate the user (via the =UserService=)
3. Retrieve the contents of the response from the service layer
4. Send the response
** Services
Services are responsible for all the logic that happens in the
application. Methods are provided for i.e. authentication, trading, and
battling. The pattern here is more variable but follows this general list of objectives:
- Sanity checking of data
- Usage of repository methods for input/output from the database
- Performance of some kind of operation on the data such as calculating a user's stats
- Returning valid data
** Models
Models define the actual "objects" involved in the application. These can be
more or less concrete, but they serve a couple of purposes:
- Structuring data
- Defining objects
** Repositories
Repositories depend on the models for defining what the database schema should
look like. The repository then provides simplistic database IO, including
creating, reading, updating, and deleting data. (CRUD)
- Defines schema
- Provides input/output
- Data validation, in the sense that only data which conforms to the models can
  be read/inserted/etc.

* Lessons Learned

* Time Spent
Note: This information is only approximate; there were times when I worked on it
without recording the time spent, and there were times where the clock was
running while I took a break, etc.

Furthermore, for simplicity, I didn't split up the time spent working on
Controllers and Services, or from one Controller to another. I decided that
constantly worrying about the running clock and which context it was in wasn't
worth the mental effort.

I categorized the Controllers, Services, Repositories, and Models into roughly
four areas according to the OpenAPI specification:
1. Users
2. Cards
3. Trading
4. Battle

I wrote them in this order, and mostly worked on the Repositories and Models
first, then the Controllers, and finally the Services.

I spent more time (on the order of maybe four hours) on the Database,
Synchronization, and Unit Test categories than is recorded here in particular,
as I often needed to research these topics in order to understand certain
implementation details and strategies.

#+BEGIN: clocktable :scope file :maxlevel 2
#+CAPTION: Clock summary at [2023-02-24 Fri 12:50]
| Headline                          | Time    |          |
|-----------------------------------+---------+----------|
| *Total time*                        | *2d 2:01* |          |
|-----------------------------------+---------+----------|
| [[file:./mtcg.pdf][Monster Card Game]]                 | 2d 2:01 |          |
| \_  Database [4/4]                |         |     5:59 |
| \_  Controllers [4/4]             |         | 1d 12:29 |
| \_  Unique Feature [1/1]          |         |     1:10 |
| \_  Synchronization [2/2]         |         |     2:13 |
| \_  Learn to use Unit Tests [1/1] |         |     4:10 |

* Link to git
[[https://github.com/skyler544/mtcg][MTCG]]
